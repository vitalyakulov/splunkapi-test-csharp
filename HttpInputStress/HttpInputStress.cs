//-----------------------------------------------------------------------
// <copyright file="SplunkTest.cs" company="VitalyAkulov">
//     Stress test to crash Splunk server. Copyright by Vitaly Akulov.
// </copyright>
//-----------------------------------------------------------------------

namespace SplunkTest
{
    using System;
    using System.Threading;
    using System.Threading.Tasks;
    using System.Collections.Generic;
    using System.Collections;
    using System.Xml;

    internal class SplunkTest
    {
        private static Random _random = new Random();
        private static Object _searchCounterLock = new Object();
        private static long totalAddedEvents = 0;
        private static long totalFailedEvents = 0;

        static SplunkApi getConnectedSplunk(string hostName, int durationInSec=60)
        {
            var splunk = new SplunkApi(hostName, "admin", "changeme", useSSL: false);

            var tStart = DateTime.Now;
            while ((DateTime.Now - tStart).TotalSeconds < durationInSec)
            {
                try
                {
                    splunk.Connect();
                    return splunk;
                }
                catch (Exception)
                {
                    Thread.Sleep(100);
                }
            }
            Console.WriteLine("Failed to connect to {0} in {1} seconds. Exiting ...", hostName, durationInSec);
            Environment.Exit(1);
            return null;
        }
        private static void Main(string[] args)
        {
            if (args.Length < 3)
            {
                Console.WriteLine("Usage: <hostName> <Number of threads> <test duration in seconds> [http token]");
                Console.WriteLine("Missing arguments");
                return;
            }
            string hostName = args[0];
            int threads = Convert.ToInt32(args[1]);
            int testDuration = Convert.ToInt32(args[2]);
            var splunk = getConnectedSplunk(hostName);
            string tokenName = "inputstresstest";
            string token = string.Empty;
            if(args.Length <4)
            {
                splunk.EnableHttpInput();
                splunk.DeleteHttpToken(tokenName);
                token = splunk.CreateHttpToken(tokenName);
            }
            else
            {
                token = args[3];
            }

            List<Thread> tSenders = new List<Thread>(threads);
            DateTime tStart = DateTime.Now;
            for (int i = 0; i < threads; i++)
            {
                Thread t = new Thread(new ThreadStart(delegate { SendDataViaHttpInput(hostName, token, testDuration); }));
                t.Name = string.Format("Thread {0,4}", i);
                t.Start();
                tSenders.Add(t);
            }
            foreach (Thread t in tSenders)
            {
                t.Join();
            }
            TimeSpan elapsedTime = DateTime.Now - tStart;
            Console.WriteLine("It took {0:F2} seconds overall to generate data, {4:F2} events/sec. {1} ({3} failed) events were generated by {2} threads", elapsedTime.TotalSeconds, totalAddedEvents, threads, totalFailedEvents, totalAddedEvents/elapsedTime.TotalSeconds);
            // Remove after debugging
            bool showSearchOutput = false;

            // Now wait for index to complete
            XmlDocument searchResults = splunk.Search("*|stats count", false, 10, showStats: showSearchOutput);
            var context = new XmlNamespaceManager(searchResults.NameTable);
            int eventCount = int.Parse(searchResults.SelectSingleNode("/results/result/field[@k='count']/value", context).InnerText);
            for (int i = 0; i < 4; i++)
            {
                do
                {
                    if (showSearchOutput)
                        Console.WriteLine("\tWaiting for indexing to complete, {0} events so far", eventCount);
                    Thread.Sleep(10000);
                    searchResults = splunk.Search("*|stats count", false, 10, showStats: showSearchOutput);
                    context = new XmlNamespaceManager(searchResults.NameTable);
                    int updatedEventCount = int.Parse(searchResults.SelectSingleNode("/results/result/field[@k='count']/value", context).InnerText);
                    if (updatedEventCount == eventCount)
                        break;
                    eventCount = updatedEventCount;
                } while (true);
                if (showSearchOutput)
                    Console.WriteLine("\tCompleted wait for iteration {0}", i);
            }
        }

        private static void SendDataViaHttpInput(string hostName, string token, int durationInSec)
        {
            long addedEvents = 0, failedEvents = 0;
            try
            {
                var splunk = getConnectedSplunk(hostName);

                var tStart = DateTime.Now;
                int i = 0;
                while ((DateTime.Now - tStart).TotalSeconds < durationInSec)
                {
                    string eventBody = "{ \"event\": { \"data\": \"Thread: " + Thread.CurrentThread.Name + ", event: " + i.ToString() + "\" } }";
                    bool result = splunk.SendDataViaHttp(token, eventBody);
                    if (result)
                        addedEvents++;
                    i++;
                }
            }
            catch (Exception)
            {
                failedEvents++;
            }
            Interlocked.Add(ref totalAddedEvents, addedEvents);
            Interlocked.Add(ref totalFailedEvents, failedEvents);
        }
    }
}