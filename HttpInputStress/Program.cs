//-----------------------------------------------------------------------
// <copyright file="SplunkTest.cs" company="VitalyAkulov">
//     Stress test to crash Splunk server. Copyright by Vitaly Akulov.
// </copyright>
//-----------------------------------------------------------------------

namespace SplunkTest
{
    using System;
    using System.Threading;
    using System.Threading.Tasks;
    using System.Collections.Generic;
    using System.Collections;
    using System.Xml;

    internal class SplunkTest
    {
        private static Random _random = new Random();
        private static Object _searchCounterLock = new Object();
        private static long totalEvents = 0;
        private static void Main(string[] args)
        {
            if (args.Length < 3)
            {
                Console.WriteLine("Usage: <hostName> <Number of threads> <test duration in seconds>");
                Console.WriteLine("Missing arguments");
                return;
            }
            string hostName = args[0];
            int threads = Convert.ToInt32(args[1]);
            int testDuration = Convert.ToInt32(args[2]);
            string tokenName = "inputstresstest";

            var splunk = new SplunkApi(hostName, "admin", "changeme");
            splunk.Connect();
            splunk.EnableHttpInput();
            splunk.DeleteHttpToken(tokenName);
            string token = splunk.CreateHttpToken(tokenName);
            List<Thread> tSenders = new List<Thread>(threads);
            DateTime tStart = DateTime.Now;
            for (int i = 0; i < threads; i++)
            {
                Thread t = new Thread(new ThreadStart(delegate { SendDataViaHttpInput(hostName, token, testDuration); }));
                t.Name = string.Format("Thread {0,4}", i);
                t.Start();
                tSenders.Add(t);
            }
            foreach (Thread t in tSenders)
            {
                t.Join();
            }
            TimeSpan elapsedTime = DateTime.Now - tStart;
            Console.WriteLine("It took {0:F2} seconds overall to generate data. {1} events were generated by {2} threads", elapsedTime.TotalSeconds, totalEvents, threads);
            // Now wait for index to complete
            XmlDocument searchResults = splunk.Search("*|stats count", false, 10);
            var context = new XmlNamespaceManager(searchResults.NameTable);
            int eventCount = int.Parse(searchResults.SelectSingleNode("/results/result/field[@k='count']/value", context).InnerText);
            for (int i = 0; i < 4; i++)
            {
                do
                {
                    Console.WriteLine("\tWaiting for indexing to complete, {0} events so far", eventCount);
                    Thread.Sleep(10000);
                    searchResults = splunk.Search("*|stats count", false, 10);
                    context = new XmlNamespaceManager(searchResults.NameTable);
                    int updatedEventCount = int.Parse(searchResults.SelectSingleNode("/results/result/field[@k='count']/value", context).InnerText);
                    if (updatedEventCount == eventCount)
                        break;
                    eventCount = updatedEventCount;
                } while (true);
                Console.WriteLine("\tCompleted wait for iteration {0}", i);
            }
        }

        private static void SendDataViaHttpInput(string hostName, string token, int durationInSec)
        {
            int totalCounter = 0;
            try
            {
                var splunk = new SplunkApi(hostName, "admin", "changeme");
                splunk.Connect();


                var tStart = DateTime.Now;
                int i = 0;
                while ((DateTime.Now - tStart).TotalSeconds < durationInSec)
                {
                    string eventBody = "{ \"event\": { \"data\": \"Thread: " + Thread.CurrentThread.Name + ", event: " + i.ToString() + "\" } }";
                    bool result = splunk.SendDataViaHttp(token, eventBody);
                    if (result)
                        totalCounter++;
                    i++;
                    //if (i % 1000 == 0)
                    //    Console.WriteLine("{0}\t{1} tokens were created in thread '{2}'", DateTime.Now, totalCounter, Thread.CurrentThread.Name);
                }
                //Console.WriteLine("{0}\tData generation completed, total {1} were created in thread '{2}'", DateTime.Now, i, Thread.CurrentThread.Name);
            }
            catch (Exception e)
            {
                Console.WriteLine("--- One of the threads caught an exception {0}.Exiting thread '{1}'", e.Message, Thread.CurrentThread.Name);
            }
            Interlocked.Add(ref totalEvents, totalCounter);
        }
    }
}